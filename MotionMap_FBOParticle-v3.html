<!doctype html>
<html>
  <head>
    <title>WebGL Demo</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="JS/webgl.css" type="text/css">
    <script src="JS/sylvester.js" type="text/javascript"></script>
    <script src="JS/glUtils.js" type="text/javascript"></script>
    <script src="MotionMap_FBOParticle-v3.js" type="text/javascript"></script>

 
    <!===========================似乎無法在Frag Shader讀貼圖，因為Coord的問題>   
    <!-- Vertex shader program -->
    <script id="physics-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec2 aTextureCoord;
      uniform float uTime;
      uniform float udTime;
      uniform sampler2D uParticleData;
      uniform sampler2D uPerlinData;
      uniform sampler2D uMotionMap;
      varying vec2 vTextureCoord1;//有問題
      varying vec3 FinalPos;
      varying float vTime;
      
      void main(void) {
        vTextureCoord1 = vec2(aTextureCoord.st*0.5+uTime);  //coord*0.5 慢慢瀏覽perlin texture     
        gl_Position = vec4( (aVertexPosition-0.5)*2.0, 1.0); //座標[0,1]轉換為位置座標[-1,1]
        vTime = uTime;
        //gl_Position = vec4(aVertexPosition, 1.0);
        //gl_PointSize = 2.0;
      }
    </script>
    
    <!-- Fragment shader program -->
    <script id="physics-fs" type="x-shader/x-fragment">
      precision mediump float;//關鍵，才能在Frag Shader讀貼圖，解決Coord的問題
      uniform sampler2D uParticleData;
      uniform sampler2D uPerlinData;
      uniform sampler2D uMotionMap;
      varying vec2 vTextureCoord1; //有問題，疑慮？
      varying vec3 FinalPos;
      varying float vTime;

      //
// GLSL textureless classic 3D noise "cnoise",
// with an RSL-style periodic variant "pnoise".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/ashima/webgl-noise
//

vec3 mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

// Classic Perlin noise
float cnoise(vec3 P)
{
  vec3 Pi0 = floor(P); // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}

//========== Classic Perlin noise, periodic variant
float pnoise(vec3 P, vec3 rep)
{
  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec3 Pf0 = fract(P); // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);

  vec4 gx0 = ixy0 * (1.0 / 7.0);
  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 * (1.0 / 7.0);
  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
  return 2.2 * n_xyz;
}
//==========

      //-----亂數函數-----------
      float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      void main(void) {
        vec2 fixCoord = vec2(gl_FragCoord.s/256.0, gl_FragCoord.t/256.0); //不會變動的coord，座標[0,1]
        vec2 fixCoordR = vec2((gl_FragCoord.s+1.0)/256.0, gl_FragCoord.t/256.0);
        vec2 fixCoordL = vec2((gl_FragCoord.s-1.0)/256.0, gl_FragCoord.t/256.0);
        vec2 fixCoordT = vec2(gl_FragCoord.s/256.0, (gl_FragCoord.t+1.0)/256.0);
        vec2 fixCoordB = vec2(gl_FragCoord.s/256.0, (gl_FragCoord.t-1.0)/256.0);
        
        float gradx = texture2D(uPerlinData, fixCoordR).x-texture2D(uPerlinData, fixCoordL).x;
        float grady = texture2D(uPerlinData, fixCoordT).x-texture2D(uPerlinData, fixCoordB).x;
        float gradz = texture2D(uPerlinData, fixCoord).x;
        
        vec3 NewPos;
        vec4 posPt;

        //
        /*
        posPt.xyz = vec3((fixCoord.st), 5.0);
        float intensity = cnoise(posPt.xyz*8.0); //皺褶程度
        NewPos = vec3(intensity);
        */

        
        if(vTime < 0.01)
        {
          posPt = vec4(2.0*(fixCoord.st-0.5), 0.2*rand(fixCoord), 0.0);//亂一些，有Ｚ軸厚度
          NewPos = posPt.xyz;
          //NewPos = posPt.xyz+ cnoise(posPt.xyz*8.0)*0.3; //避免過於規則
        }else
        {
          posPt = texture2D(uParticleData, fixCoord); //position map

        

        // vTime 創造不規則，範圍[0, 10]
        //vec4 velPt = texture2D(uPerlinData, posPt.xy); //以更新的pos讀取velocity map 
        //velPt.xyz = (velPt.xyz -0.5)*2.0;
        //velPt.z = 0.0;
        vec3 velPt = vec3(-1.0*grady, gradx, 0.4*gradz);
 
        float intensity = 90.0*cnoise(posPt.xyz*2.0); //皺褶程度
        vec3 forcePt = vec3(cos(intensity), sin(intensity), 1.0*cos(intensity)); //velocity map

          posPt.xyz = (posPt.xyz - 0.5)*2.0; //色彩[0,1]轉換為位置座標[-1,1]

          if(gradz<0.005)
          {
            //NewPos = posPt.xyz + 0.1*vec3(0.0, 0.0, -0.2*rand(fixCoord));
            NewPos = vec3(-1.0, -1.0, 0.0);
          }else
          {
            //若cnoise造成motionmap，則無常的motionmap即無法彰顯，因此cnoise motionmap 成形同心圓卻無法運動粒子
          //NewPos = posPt.xyz + 0.0*velPt.xyz+0.01*forcePt.xyz*(0.6+0.0*gradz) ;//運動數值velocity小於0.005會幾乎不起作用，小於0.003不作用
          //NewPos = posPt.xyz + 0.01*velPt.xyz+0.006*forcePt.xyz*(0.7+1.0*gradz) ;//0.0042亂數函數成形同心圓但不運動，0.006 gradz區域有運動作用
          NewPos = posPt.xyz + 0.006*forcePt.xyz*(0.7+0.0*gradz+2.0*velPt.xyz) ;
          //NewPos = posPt.xyz + 0.008*velPt.xyz;
          //NewPos = posPt.xyz;
          }

          
        }

        NewPos=(NewPos+1.0)*0.5; //位置座標[-1,1]轉換為色彩[0,1]

        //抵達邊界後粒子重生
        if(NewPos.x>1.0 || NewPos.x<0.0 || NewPos.y>1.0 || NewPos.y<0.0 || NewPos.z>0.7 || NewPos.z<0.3 )
        {
          NewPos = vec3(fixCoord.st, 0.5);//Z值為零，儲存為Blue Channel=0.5
          //NewPos = vec3(fixCoord.st, 0.5+0.1*rand(fixCoord));//亂一些，有Ｚ軸厚度
          //NewPos = vec3(fixCoord.st+0.05*rand(fixCoord), 0.5);
        }
        

        
        gl_FragColor = vec4(NewPos, 1.0); 
        //gl_FragData[0] 
      }
    </script>

    <!===========================似乎無法在Frag Shader讀貼圖，因為Coord的問題>
    <!-- Vertex shader program -->
    <script id="shader-vs" type="x-shader/x-vertex">
      //attribute vec3 aVertexPosition;
      //attribute vec4 aVertexColor;
      attribute vec2 aTextureCoord;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;
      uniform float uTime;
      uniform float udTime;
      //uniform sampler2D uSampler;
      uniform sampler2D uParticleData;
      varying highp vec2 vTextureCoord2;

      void main(void) {
        /* 
        vec4 noisePt=texture2D(uParticleData, aTextureCoord);
        vec4 noisePt2=texture2D(uParticleData, vec2(noisePt.st+uTime*1.0));
        vec3 noisePt3 = vec3((noisePt2.rgb-0.5)*2.0);
        gl_Position = uPMatrix * uMVMatrix * vec4(noisePt3, 1.0);
        */        
        vec4 Xpos=texture2D(uParticleData, aTextureCoord);
        gl_Position = uPMatrix * uMVMatrix * vec4((Xpos.rgb-0.5)*1.0, 1.0);//放大1.5倍
        
        gl_PointSize = 1.5;
        vTextureCoord2 = aTextureCoord;//turn off 
      }
    </script>
    
    <!-- Fragment shader program -->
    <script id="shader-fs" type="x-shader/x-fragment">
      varying highp vec2 vTextureCoord2;//有疑慮
      //uniform sampler2D uSampler;
      uniform sampler2D uParticleData;
  
      void main(void) {
        //gl_FragColor = texture2D(uParticleData, vTextureCoord2);
        gl_FragColor = vec4(0.9, 0.3, 0.1, 0.5);
        //gl_FragColor = vec4(0.1, 0.4, 0.8, 0.5);     
      }
    </script>

  </head>

  <body onload="start()">
    <canvas id="glcanvas" width="800" height="600">
      Your browser doesn't appear to support the <code>&lt;canvas&gt;</code> element.
    </canvas>
  </body>
</html>